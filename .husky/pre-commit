#!/bin/bash
set -euo pipefail

# Cache directory for expensive operations
CACHE_DIR=".husky/cache"
mkdir -p "$CACHE_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to check cache validity (cross-platform compatible)
is_cache_valid() {
  local cache_file="$1"
  local max_age=300  # 5 minutes in seconds

  if [ -f "$cache_file" ]; then
    # Cross-platform stat command
    if command -v stat >/dev/null 2>&1; then
      if stat -c %Y "$cache_file" >/dev/null 2>&1; then
        local cache_time=$(stat -c %Y "$cache_file")
      elif stat -f %m "$cache_file" >/dev/null 2>&1; then
        local cache_time=$(stat -f %m "$cache_file")
      else
        return 1
      fi
    else
      # Fallback to using file modification time with ls
      local cache_time=$(ls -la --time-style=+%s "$cache_file" 2>/dev/null | awk '{print $6}' || echo "0")
    fi

    local current_time=$(date +%s)
    local age=$((current_time - cache_time))

    [ $age -lt $max_age ]
  else
    return 1
  fi
}

# Function to mark cache as valid
update_cache() {
  local cache_file="$1"
  touch "$cache_file"
}

# Function to check if files with specific patterns are staged
has_staged_files() {
  local patterns="$1"
  git diff --cached --name-only 2>/dev/null | grep -E "$patterns" >/dev/null 2>&1
}

# Function to run command and return status with better error handling
run_cmd() {
  local cmd="$1"
  local desc="$2"
  local start_time=$(date +%s)

  echo -e "${BLUE}üîÑ Running: ${NC}$desc"

  # Set a timeout for long-running commands (15 minutes)
  if timeout 900 bash -c "$cmd" 2>&1; then
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo -e "${GREEN}‚úÖ $desc completed successfully${NC} (${duration}s)"
    return 0
  else
    local exit_code=$?
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    if [ $exit_code -eq 124 ]; then
      echo -e "${RED}‚ùå $desc timed out after 15 minutes${NC}"
    else
      echo -e "${RED}‚ùå $desc failed${NC} (${duration}s)"
    fi
    return $exit_code
  fi
}

# Function to cleanup background processes
cleanup() {
  local exit_code=$?

  # Kill any remaining background processes
  if [ ! -z "${pid_prettier:-}" ]; then
    kill "$pid_prettier" 2>/dev/null || true
  fi
  if [ ! -z "${pid_typecheck:-}" ]; then
    kill "$pid_typecheck" 2>/dev/null || true
  fi
  if [ ! -z "${pid1:-}" ]; then
    kill "$pid1" 2>/dev/null || true
  fi
  if [ ! -z "${pid2:-}" ]; then
    kill "$pid2" 2>/dev/null || true
  fi
  if [ ! -z "${pid3:-}" ]; then
    kill "$pid3" 2>/dev/null || true
  fi
  if [ ! -z "${pid4:-}" ]; then
    kill "$pid4" 2>/dev/null || true
  fi
  if [ ! -z "${pid5:-}" ]; then
    kill "$pid5" 2>/dev/null || true
  fi

  exit $exit_code
}

# Set trap to cleanup on exit
trap cleanup EXIT INT TERM

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  echo -e "${RED}‚ùå Not in a git repository${NC}"
  exit 1
fi

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only 2>/dev/null)" ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  No staged files found. Skipping pre-commit checks.${NC}"
  echo -e "${CYAN}üí° Tip: Stage your files with 'git add' before committing${NC}"
  exit 0
fi

# Detect what types of files changed
HAS_FRONTEND=$(has_staged_files "\.(ts|tsx|js|jsx)$" && echo "true" || echo "false")
HAS_BACKEND=$(has_staged_files "\.py$" && echo "true" || echo "false")
HAS_CONFIG=$(has_staged_files "\.(json|yml|yaml|toml|md)$" && echo "true" || echo "false")

echo -e "${PURPLE}üìã Changed file types detected:${NC}"
echo -e "   ${CYAN}Frontend files:${NC} $HAS_FRONTEND"
echo -e "   ${CYAN}Backend files:${NC} $HAS_BACKEND"
echo -e "   ${CYAN}Config files:${NC} $HAS_CONFIG"

failed=0
start_time=$(date +%s)

# Frontend checks (if frontend files changed)
if [ "$HAS_FRONTEND" = "true" ]; then
  echo -e "\n${PURPLE}üé® Running frontend checks...${NC}"

  # Check if frontend directory and package.json exist
  if [ ! -d "frontend" ] || [ ! -f "frontend/package.json" ]; then
    echo -e "${RED}‚ùå Frontend directory or package.json not found${NC}"
    exit 1
  fi

  # Auto-format code with Prettier first
  (run_cmd "cd frontend && npm run prettier:fix" "Prettier auto-formatting") &
  pid_prettier=$!

  # Run TypeScript type checking
  (run_cmd "cd frontend && npm run typecheck" "TypeScript type checking") &
  pid_typecheck=$!

  # Then run tests
  (run_cmd "npm run test:frontend" "Frontend tests") &
  pid1=$!
else
  echo -e "${YELLOW}‚è≠Ô∏è  Skipping frontend checks (no frontend files changed)${NC}"
fi

# Backend checks (if backend files changed OR if this is a comprehensive check)
if [ "$HAS_BACKEND" = "true" ] || [ "$HAS_CONFIG" = "true" ]; then
  echo -e "\n${PURPLE}üîß Running backend checks...${NC}"

  # Check if backend directory exists
  if [ ! -d "backend" ]; then
    echo -e "${RED}‚ùå Backend directory not found${NC}"
    exit 1
  fi

  (run_cmd "npm run test:backend" "Backend tests") &
  pid2=$!

  (run_cmd "npm run format:backend" "Python formatting check") &
  pid3=$!

  (run_cmd "npm run vet:backend" "Python linting check") &
  pid4=$!
else
  echo -e "${YELLOW}‚è≠Ô∏è  Skipping backend checks (no backend or config files changed)${NC}"
fi

# Security audit with caching (only if cache is stale)
if ! is_cache_valid "$CACHE_DIR/security_audit"; then
  echo -e "\n${PURPLE}üîí Running security audit...${NC}"
  (run_cmd "npm run audit" "Security vulnerability check") &
  pid5=$!
  update_cache "$CACHE_DIR/security_audit"
else
  echo -e "${YELLOW}‚è≠Ô∏è  Skipping security audit (cached result still valid)${NC}"
fi

# Wait for all parallel processes to complete
echo -e "\n${CYAN}‚è≥ Waiting for all checks to complete...${NC}"

# Wait for frontend checks if they were started
if [ "$HAS_FRONTEND" = "true" ]; then
  echo -e "${BLUE}üì¶ Waiting for frontend processes...${NC}"
  if [ ! -z "${pid_prettier:-}" ]; then
    if ! wait "$pid_prettier"; then
      echo -e "${RED}‚ùå Prettier formatting failed${NC}"
      failed=1
    fi
  fi
  if [ ! -z "${pid_typecheck:-}" ]; then
    if ! wait "$pid_typecheck"; then
      echo -e "${RED}‚ùå TypeScript type checking failed${NC}"
      failed=1
    fi
  fi
  if [ ! -z "${pid1:-}" ]; then
    if ! wait "$pid1"; then
      echo -e "${RED}‚ùå Frontend tests failed${NC}"
      failed=1
    fi
  fi
fi

# Wait for backend checks if they were started
if [ "$HAS_BACKEND" = "true" ] || [ "$HAS_CONFIG" = "true" ]; then
  echo -e "${BLUE}üêç Waiting for backend processes...${NC}"
  if [ ! -z "${pid2:-}" ]; then
    if ! wait "$pid2"; then
      echo -e "${RED}‚ùå Backend tests failed${NC}"
      failed=1
    fi
  fi
  if [ ! -z "${pid3:-}" ]; then
    if ! wait "$pid3"; then
      echo -e "${RED}‚ùå Python formatting failed${NC}"
      failed=1
    fi
  fi
  if [ ! -z "${pid4:-}" ]; then
    if ! wait "$pid4"; then
      echo -e "${RED}‚ùå Python linting failed${NC}"
      failed=1
    fi
  fi
fi

# Wait for security audit if it was started
if [ -n "${pid5:-}" ]; then
  echo -e "${BLUE}üîí Waiting for security audit...${NC}"
  if ! wait "$pid5"; then
    echo -e "${RED}‚ùå Security audit failed${NC}"
    failed=1
  fi
fi

# Calculate total execution time
end_time=$(date +%s)
total_duration=$((end_time - start_time))

# Final status report
echo -e "\n${PURPLE}üìä Pre-commit Summary:${NC}"
echo -e "${CYAN}‚è±Ô∏è  Total execution time: ${total_duration}s${NC}"

if [ $failed -eq 1 ]; then
  echo -e "${RED}‚ùå Some checks failed!${NC}"
  echo -e "${YELLOW}üîß Please fix the issues above and try again.${NC}"
  echo -e "${CYAN}üí° You can run individual checks manually:${NC}"
  echo -e "   ${CYAN}‚Ä¢ Frontend: cd frontend && npm run typecheck${NC}"
  echo -e "   ${CYAN}‚Ä¢ Backend: npm run test:backend${NC}"
  echo -e "   ${CYAN}‚Ä¢ Security: npm run audit${NC}"
  exit 1
else
  echo -e "${GREEN}‚úÖ All checks passed successfully!${NC}"
  echo -e "${CYAN}üéâ Your code is ready for commit.${NC}"
fi
